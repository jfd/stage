#!/usr/bin/env node

/***package
{
  "author": "{{=author}}",
  "name": "{{=name}}",
  "version": "{{=version}}",
  "dependencies": {
  },
  "scripts": {
    "test": "node test.js",
    "stagetest": "node test.js"
  },
  "engines": {
    "node": ">=0.7.7"
  }
}
*/


/***test

// {{=name}}
// This test can be used as a template for your own test. The script is divided
// into two phases, compatible phase and setup phase. The compatible phase
// checks if Stage signals are supported.
// 
// If so, we need to signal the parent process once that all setup
// routines is done.
//
// Generated by: {{=program}}, version {{=version}}

"use strict";


function runTest () {
  // Your test code goes here...
  console.log("Test finished successfully!!");
  process.exit(0);
}


function initStage () {
  var parent = parseInt(process.env["STAGE_PARENT_PID"]);
  var signal = process.env["STAGE_PARENT_SIGNAL"];

  // The PID of parent is set if we are executed as a Stage test
  if (!parent || isNaN(parent)) {
    return false;
  }

  // Wait for parent to signal us. When it does, start the test
  process.stdin.resume();
  process.on(signal, runTest);

  // Stage was initialized for this test. Returning true indicates
  // that we should send a signal to parent when we are ready to
  // go.
  return true;
}


function ready () {
  var parent = parseInt(process.env["STAGE_PARENT_PID"]);
  var signal = process.env["STAGE_PARENT_SIGNAL"];
  process.kill(parent, signal);
}

// Check if this script was called by a Stage process. If not, it was
// probably called by NPM or antoher testing suite.
if (initStage() == true) {

  // Do all your asynchronized calls here.....
  
  // Signal the parent process when you are ready to start the test.
  ready();
} else {

  // You can choose to exit the process with an exit code at this
  // time. This template is running the test even if not called by
  // Stage.
  runTest();
}
*/

"use strict";

var exec                      = require("child_process").exec;

var readFileSync              = require("fs").readFileSync;
var writeFileSync             = require("fs").writeFileSync;
var existsSync                = require("fs").existsSync;
var mkdirSync                 = require("fs").mkdirSync;
var statSync                  = require("fs").statSync;

var resolve                   = require("path").resolve;
var basename                  = require("path").basename;
var dirname                   = require("path").dirname;

var format                    = require("util").format;

var version                   = require("../lib/cliutil").version;
var usage                     = require("../lib/cliutil").usage;
var help                      = require("../lib/cliutil").help;
var halt                      = require("../lib/cliutil").halt;
var url                       = require("../lib/cliutil").url;


var DEFAULT_OPTIONS           = { "basepath"    : process.cwd(),
                                  "author"      : process.env["STAGE_AUTHOR"] ||
                                                  process.env["USER"],
                                  "version"     : "1.0.0",
                                  "name"        : null,
                                  "force"       : false
                                };


var options                   = Object.create(DEFAULT_OPTIONS);


function main () {
  var args = process.argv.slice(2);
  var packagePath;
  var testPath;
  var arg;

  while ((arg = args.shift())) {
    switch (arg) {

      case "-v":
      case "--version":
      return version();

      case "--usage":
      return usage("<path>");

      case "--help":
      return help();

      case "--force":
      options.force = true;
      break;

      case "--package-author":
      options.author = args.shift();
      break;

      case "--package-name":
      options.name = args.shift();
      break;

      case "--package-version":
      options.version = args.shift();
      break;

      default:

      if (arg[0] == "-") {
        halt("unknown option " + arg);
      }

      options.basepath = resolve(arg);
      break;
    }
  }


  if (!options.author) {
    halt("Option --package-author must be set");
  }

  packagePath = resolve(options.basepath, "package.json");
  testPath = resolve(options.basepath, "test.js");

  if (existsSync(packagePath) && !options.force) {
    halt("File '" + packagePath + "' already exists");
  }

  if (existsSync(testPath) && !options.force) {
    halt("File '" + packagePath + "' already exists");
  }

  if (!options.name) {
    options.name = basename(options.basepath);
  }

  mkdirp(options.basepath);

  writePackageJson(packagePath);
  writeTestJs(testPath);

  console.log("Test '%s@%s' was successfully initialized",
              options.name,
              options.version);
}


function writePackageJson (path) {
  var content;
  var context;

  content = getNamedSection("package");

  context = {
    name        : options.name,
    version     : options.version,
    author      : options.author
  };

  writeFileSync(path, template(content, context));
}


function writeTestJs (path) {
  var content;
  var context;

  content = getNamedSection("test");

  context = {
    name        : options.name,
    program     : basename(process.argv[1]),
    version     : require("../package").version
  };

  writeFileSync(path, template(content, context));
}


// Based on https://github.com/substack/node-mkdirp/blob/master/index.js
function mkdirp (path, mode, made) {
  var stat;

  if (mode === undefined) {
    mode = 0x1ff & (~process.umask());
  }

  if (!made) {
    made = null;
  } 

  path = resolve(path);

  try {
    mkdirSync(path, mode);
    made = made || path;    
  } catch (er) {
    if (er.code == "ENOENT") {
      made = mkdirp(dirname(path), mode, made);
      mkdirp(path, mode, made);
    } else {
      try {
        stat = statSync(path);
      } catch (err) {
        throw er;
      }
      if (stat.isDirectory() == false) {
        throw er;
      }
    }
  }

  return made;
}


function template (content, context) {
  var re;
  context = context || {};
  for (var k in context) {
    re = new RegExp("{{=" + k + "}}");
    content = content.replace(re, context[k]);
  }
  return content;
}


function getNamedSection (name) {
  var splitre = /(\/\*\*\*[^*]+\*\/)/;
  var sectionre = /\/\*\*\*([a-z]+)\n([^*]+)\*\//gi;
  var content;
  var sections;
  var section;
  var match;

  content = readFileSync(__filename).toString();
  sections = content.split(splitre);

  for (var i = 0; i < sections.length; i++) {
    section = sections[i];
    match = sectionre.exec(section);
    if (match && match[1] == name) {
      return match[2];
    }
  }
}


if (process.argv[1] == __filename) {
  main();
}
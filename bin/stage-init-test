#!/usr/bin/env node

/***package
{
  "author": "{{=author}}",
  "name": "{{=name}}",
  "version": "{{=version}}",
  "dependencies": {
  },
  "scripts": {
    "test": "node test.js",
    "stagetest": "node test.js"
  },
  "engines": {
    "node": ">=0.7.7"
  }
}
*/


/***test

// {{=name}}
// This test can be used as a template for your own test. The script is divided
// into two phases, compatible phase and setup phase. The compatible phase
// checks if Stage signals are supported.
// 
// If so, we need to signal the parent process once that all setup
// routines is done.
//
// Generated by: {{=program}}, version {{=version}}

'use strict';


function runTest () {
  // Your test code goes here...
  console.log('Test finished successfully!!');
  process.exit(0);
}


function initStage () {
  var parent = parseInt(process.env['STAGE_PARENT_PID']);
  var signal = process.env['STAGE_PARENT_SIGNAL'];

  // The PID of parent is set if we are executed as a Stage test
  if (!parent || isNaN(parent)) {
    return false;
  }

  // Wait for parent to signal us. When it does, start the test
  process.stdin.resume();
  process.on(signal, runTest);

  // Stage was initialized for this test. Returning true indicates
  // that we should send a signal to parent when we are ready to
  // go.
  return true;
}


function ready () {
  var parent = parseInt(process.env['STAGE_PARENT_PID']);
  var signal = process.env['STAGE_PARENT_SIGNAL'];
  process.kill(parent, signal);
}

// Check if this script was called by a Stage process. If not, it was
// probably called by NPM or antoher testing suite.
if (initStage() == true) {

  // Do all your asynchronized calls here.....
  
  // Signal the parent process when you are ready to start the test.
  ready();
} else {

  // You can choose to exit the process with an exit code at this
  // time. This template is running the test even if not called by
  // Stage.
  runTest();
}
*/

'use strict';

var exec                      = require('child_process').exec;

var readFileSync              = require('fs').readFileSync;
var writeFileSync             = require('fs').writeFileSync;
var existsSync                = require('fs').existsSync;
var mkdirSync                 = require('fs').mkdirSync;
var statSync                  = require('fs').statSync;

var resolve                   = require('path').resolve;
var basename                  = require('path').basename;
var dirname                   = require('path').dirname;

var format                    = require('util').format;

var version                   = require('../lib/cliutil').version;
var usage                     = require('../lib/cliutil').usage;
var help                      = require('../lib/cliutil').help;
var halt                      = require('../lib/cliutil').halt;
var url                       = require('../lib/cliutil').url;


var DEFAULT_OPTIONS           = { 'basepath'    : process.cwd(),
                                  'author'      : process.env['STAGE_AUTHOR'] ||
                                                  process.env['USER'],
                                  'version'     : '1.0.0',
                                  'name'        : null,
                                  'force'       : false
                                };


var options                   = Object.create(DEFAULT_OPTIONS);


function main () {
  var args = process.argv.slice(2);
  var packagePath;
  var testPath;
  var arg;

  while ((arg = args.shift())) {
    switch (arg) {

      case '-v':
      case '--version':
      return version();

      case '--usage':
      return usage('<path>');

      case '--help':
      return help();

      case '--force':
      options.force = true;
      break;

      case '--package-author':
      options.author = args.shift();
      break;

      case '--package-name':
      options.name = args.shift();
      break;

      case '--package-version':
      options.version = args.shift();
      break;

      default:

      if (arg[0] == '-') {
        halt('unknown option ' + arg);
      }

      options.basepath = resolve(arg);
      break;
    }
  }


  if (!options.author) {
    halt('Option --package-author must be set');
  }

  packagePath = resolve(options.basepath, 'package.json');
  testPath = resolve(options.basepath, 'test.js');

  if (existsSync(packagePath) && !options.force) {
    halt('File "' + packagePath + '" already exists');
  }

  if (existsSync(testPath) && !options.force) {
    halt('File "' + packagePath + '" already exists');
  }

  if (!options.name) {
    options.name = basename(options.basepath);
  }

  mkdirp(options.basepath);

  writePackageJson(packagePath);
  writeTestJs(testPath);

  console.log('Test "%s@%s" was successfully initialized',
              options.name,
              options.version);
}


function writePackageJson (path) {
  var content;
  var context;

  content = getNamedSection('package');

  context = {
    name        : options.name,
    version     : options.version,
    author      : options.author
  };

  writeFileSync(path, template(content, context));
}


function writeTestJs (path) {
  var content;
  var context;

  content = getNamedSection('test');

  context = {
    name        : options.name,
    program     : basename(process.argv[1]),
    version     : require('../package').version
  };

  writeFileSync(path, template(content, context));
}


// Based on https://github.com/substack/node-mkdirp/blob/master/index.js
function mkdirp (path, mode, made) {
  var stat;

  if (mode === undefined) {
    mode = 0x1ff & (~process.umask());
  }

  if (!made) {
    made = null;
  } 

  path = resolve(path);

  try {
    mkdirSync(path, mode);
    made = made || path;    
  } catch (er) {
    if (er.code == 'ENOENT') {
      made = mkdirp(dirname(path), mode, made);
      mkdirp(path, mode, made);
    } else {
      try {
        stat = statSync(path);
      } catch (err) {
        throw er;
      }
      if (stat.isDirectory() == false) {
        throw er;
      }
    }
  }

  return made;
}


function template (content, context) {
  var re;
  context = context || {};
  for (var k in context) {
    re = new RegExp('{{=' + k + '}}');
    content = content.replace(re, context[k]);
  }
  return content;
}


function getNamedSection (name) {
  var splitre = /(\/\*\*\*[^*]+\*\/)/;
  var sectionre = /\/\*\*\*([a-z]+)\n([^*]+)\*\//gi;
  var content;
  var sections;
  var section;
  var match;

  content = readFileSync(__filename).toString();
  sections = content.split(splitre);

  for (var i = 0; i < sections.length; i++) {
    section = sections[i];
    match = sectionre.exec(section);
    if (match && match[1] == name) {
      return match[2];
    }
  }
}


if (process.argv[1] == __filename) {
  main();
}